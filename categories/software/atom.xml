<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Software | Deprecated Behaviour]]></title>
  <link href="http://blog.tekerson.com/categories/software/atom.xml" rel="self"/>
  <link href="http://blog.tekerson.com/"/>
  <updated>2013-08-18T22:48:20+10:00</updated>
  <id>http://blog.tekerson.com/</id>
  <author>
    <name><![CDATA[Brenton Alker]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Share tmux Windows Across Sessions]]></title>
    <link href="http://blog.tekerson.com/2013/05/28/share-tmux-windows-across-sessions/"/>
    <updated>2013-05-28T16:01:00+10:00</updated>
    <id>http://blog.tekerson.com/2013/05/28/share-tmux-windows-across-sessions</id>
    <content type="html"><![CDATA[<p>When working in a terminal (the vast majority of the time) I run the terminal multiplexer <a href="http://tmux.sourceforge.net/">tmux</a>, with one session for each project I am currently working on. I like to have a window for my IRC client in every session, so I can keep an eye on it. The best way to do this is to share the tmux window across multiple tmux sessions.</p>

<p>To perform this setup, we can create a new session for "shared" applications, opening irssi in a window named "irc". Either manually create the windows and open the applications in them, or, if you're lazy and use the same setup regularly. Script it, something like so:</p>

<pre><code>tmux new-session -s shared "tmux new-window -n irc irssi"
</code></pre>

<p>You can use the automatically-assigned window names, but since I'm referencing them across sessions, I feel explicitly naming them (with the <code>-n</code>) is more robust.</p>

<p>Once the applications are running, we can link the windows to the working session using tmux's <code>link-window</code> command, which has the basic form:</p>

<pre><code>tmux link-window -s &lt;src-window&gt; -t &lt;dst-window&gt;
</code></pre>

<p>Any time a tmux command requires a reference to a window, we can provide an absolute reference to any window in any session using the <code>session:window</code> format where <code>session</code> is the name of the session and <code>window</code> is the name (or number) of the window in that session.</p>

<p>Using this, we can use the <code>link-window</code> our "shared:irc" window to index "9" in the current session. Which looks like:</p>

<pre><code>tmux link-window -s shared:irc -t 9
</code></pre>

<p>The target parameter is optional, without it the window will be placed in the next available index, but I like to place it at the end of the list so they don't get in the way of my "real work".</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Basic branching with git]]></title>
    <link href="http://blog.tekerson.com/2008/09/05/basic-branching-with-git/"/>
    <updated>2008-09-05T22:48:22+10:00</updated>
    <id>http://blog.tekerson.com/2008/09/05/basic-branching-with-git</id>
    <content type="html"><![CDATA[<p>With 3 long-running tasks concurrently on my plate, I finally got around to learning branching in <a href="http://git.or.cz/">git</a>, and it's <strong>easy!</strong></p>

<p>Until this week, I had managed to get by without learning to branch. I have looked previously but got a little lost. I often temporarily stored my work using "<a href="http://www.kernel.org/pub/software/scm/git/docs/git-stash.html">git-stash</a>" to work on multiple things at once, but this is very limiting.</p>

<p>So, Here we go. My basic workflow now look like this.</p>

<p>Create a new branch (based on the HEAD of your current branch), and automatically switch to it:</p>

<pre><code>&lt;code&gt;&lt;a href="http://www.kernel.org/pub/software/scm/git/docs/git-checkout.html" title="git-checkout manual page"&gt;git checkout&lt;/a&gt; -b my_branch&lt;/code&gt;
</code></pre>

<p>Then you can work within this branch as you always would.</p>

<p>Work, work, work...</p>

<pre><code>&lt;code&gt;&lt;a&gt;&lt;/a&gt;&lt;a href="http://www.kernel.org/pub/software/scm/git/docs/git-add.html" title="git-add manual page"&gt;git add&lt;/a&gt; files_i_have_edited.txt
&lt;a href="http://www.kernel.org/pub/software/scm/git/docs/git-commit.html" title="git-commit manual page"&gt;git commit&lt;/a&gt; -m 'My changes'&lt;/code&gt;
</code></pre>

<p>Repeating this step until the task is complete. Then, to get the changes back into the master branch. Switch to it</p>

<pre><code>&lt;code&gt;&lt;a href="http://www.kernel.org/pub/software/scm/git/docs/git-checkout.html" title="git-checkout manual page"&gt;git checkout&lt;/a&gt; master&lt;/code&gt;
</code></pre>

<p>And pull the changes from the branch</p>

<pre><code>&lt;code&gt;&lt;a href="http://www.kernel.org/pub/software/scm/git/docs/git-pull.html" title="git-pull manual page"&gt;git pull&lt;/a&gt; . my_branch&lt;/code&gt;
</code></pre>

<p>Easy. No need to remember revision numbers where you branched, or which changed have already been merged. You can of course switch back to the branch and continue work with</p>

<pre><code>&lt;code&gt;&lt;a href="http://www.kernel.org/pub/software/scm/git/docs/git-checkout.html" title="git-checkout manual page"&gt;git checkout&lt;/a&gt; my_branch&lt;/code&gt;
</code></pre>

<p>this "edit, commit, pull" cycle can continue until the task is complete. Then, once you're satisfied you can delete the branch with</p>

<pre><code>&lt;code&gt;&lt;a href="http://www.kernel.org/pub/software/scm/git/docs/git-branch.html" title="git-branch manual page"&gt;git branch&lt;/a&gt; -d my_branch&lt;/code&gt;
</code></pre>

<p>It's still in the history of course, but no need to keep old branches around.</p>

<p>Hope that makes things clear to anyone else who was confused as I was by some of the overly complicated explanation of branching in git.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Initial thoughts on CouchDB]]></title>
    <link href="http://blog.tekerson.com/2008/04/15/initial-thoughts-on-couchdb/"/>
    <updated>2008-04-15T01:18:33+10:00</updated>
    <id>http://blog.tekerson.com/2008/04/15/initial-thoughts-on-couchdb</id>
    <content type="html"><![CDATA[<p>Since I was first introduced to <a href="http://incubator.apache.org/couchdb/">CouchDB</a> late last year when Jan Lehnardt discussed it on the <a href="http://devzone.zend.com/article/2857-PHP-Abstract-Podcast-Episode-30-CouchDB">PHP Abstract Podcast</a> my interest was piqued. I have since read as much as I can about it, which doesn't actually amount to a great deal unfortunately. However, I think the idea has merit as an alternative to relational databases in various scenarios.</p>

<p>I have been using <a href="http://www.danga.com/memcached/">memcached</a> to store aggregated objects and it often seems pointless to break them into disparate parts to fit into a relational schema. While I realise CouchDB is not an object cache, being able to store data "as is", in a form (JSON) that is directly malleable by many languages makes a lot of sense.</p>

<p>The "views", used to retrieve data, select the documents to return by passing them through user defined JavaScript filter functions, instead of querying using SQL as in most relational databases; providing near infinite flexibility for data retrieval.</p>

<p>The major concern that I haven't seen adequately addressed is performance, especially given larger datasets. With the unstructured nature of the data and the flexibility of the view functions, it seems performance could be a challenge. Though given <a href="http://www.erlang.org/">Erlang</a>'s ground up concurrency and some of the algorithmic genius they have apparently borrowed from <a href="http://labs.google.com/papers/mapreduce.html">Google's MapReduce</a> -- datasets don't get much larger than that -- I might yet be proved wrong. I hope I am.</p>
]]></content>
  </entry>
  
</feed>
