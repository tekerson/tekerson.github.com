<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaScript | Deprecated Behaviour]]></title>
  <link href="http://blog.tekerson.com/categories/javascript/atom.xml" rel="self"/>
  <link href="http://blog.tekerson.com/"/>
  <updated>2015-07-15T22:52:21+10:00</updated>
  <id>http://blog.tekerson.com/</id>
  <author>
    <name><![CDATA[Brenton Alker]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Value Objects in JavaScript]]></title>
    <link href="http://blog.tekerson.com/2015/07/15/value-objects-in-javascript/"/>
    <updated>2015-07-15T21:31:43+10:00</updated>
    <id>http://blog.tekerson.com/2015/07/15/value-objects-in-javascript</id>
    <content type="html"><![CDATA[<p>Value Objects are awesome! Many of the JavaScript applications I have encountered don&rsquo;t explicitly define their domain objects at all, instead passing primitives or raw object literals around.  Value Objects can define the values in an way that allows discussion and reasoning about the values being passed around. As well as a logical place to &ldquo;put code&rdquo;.</p>

<p>To explore their use, lets start by defining a simple Value Object &ndash; Distance &ndash; because I don&rsquo;t claim to be creative in these matters.</p>

<p>About the simplest way of defining a Value Object is like this.</p>

<p><code>javascript
function Distance(value, unit) {
  this.value = value;
  this.unit = unit;
}
</code></p>

<p>This is a good start and really isn&rsquo;t much more difficult that using object literals. Given the other advantages (that can be added incrementally), I don&rsquo;t see a down side.</p>

<p>But, but we can do better!</p>

<h2>Immutability</h2>

<p>My first step would be to make it immutable. Immutability is a great property to have, especially for things being passed around a lot. For Value Objects, I think it is a reasonable default.</p>

<p><code>javascript
function Distance(value, unit) {
  this.value = value;
  this.unit = unit;
  return Object.freeze(this);
}
</code></p>

<p>Now, <code>Object.freeze</code> isn&rsquo;t perfect. It only freezes the object itself; nested properties can still be mutated. But, I still think it&rsquo;s worth it to prevent accidental mutation, or third party code mutating your objects without your knowledge (I&rsquo;m looking at you, <code>ng-repeat</code>).</p>

<h2>Validation</h2>

<p>The next issue to look at is validation of the fields. <code>new Distance(12, 'parsecs');</code> would ostensibly give a valid <code>Distance</code>, but it probably wouldn&rsquo;t be very useful. We can use the constructor function to check the parameters, ensuring only valid values can be created. In this case, say &ndash; A distance is a positive whole number measured in centimetres, metres or kilometres.</p>

<p>It might be implemented this way:</p>

<p>``` javascript
function Distance(value, unit) {
  if (parseInt(value, 10) !== value) {</p>

<pre><code>return new TypeError('Distance Value is not a decimal number');
</code></pre>

<p>  }
  if (Distance.units.indexOf(unit) === -1) {</p>

<pre><code>return new TypeError('Distance Unit is not is not valid');
</code></pre>

<p>  }</p>

<p>  this.value = value;
  this.unit = unit;
  return Object.freeze(this);
}
Distance.units = [&lsquo;cm&rsquo;, &rsquo;m', &lsquo;km&rsquo;];
```</p>

<p>The decision to <code>return</code> the <code>Error</code>s instead of <code>throw</code> them is probably debatable, but I don&rsquo;t think validation errors are &ldquo;exceptional&rdquo; and find it composes better with higher order functions (eg. <code>map</code>, <code>filter</code>, <code>reduce</code>) which I generally use a lot of. Either way, the point is it won&rsquo;t get back a valid <code>Distance</code> object. And, since they are immutable, a valid <code>Distance</code> only ever be valid.</p>

<h2>Logic</h2>

<p>Once a Value Object is defined, it becomes a great place to put some logic. Normalization and comparison logic is a good candidate. For example, adding methods to compare two distances.</p>

<p><code>javascript
Distance.multipliers = [1, 100, 100000];
Distance.prototype.toCentimetres = function () {
  var multiplier = Distance.multipliers[Distance.units.indexOf(this.unit)];
  return this.value * multiplier;
};
Distance.prototype.isCloserThan = function (other) {
  return this.toCentimetres() &lt; other.toCentimetres();
};
</code></p>

<p>It&rsquo;s also a good place to add domain logic; the application may define how far is considered &ldquo;walkable&rdquo;. By having the Value Object, it provides somewhere for this knowledge to go and prevents <code>if (distance &lt; 5)</code> being duplicated across the application.</p>

<p><code>javascript
Distance.walkable = new Distance(5, 'km');
Distance.prototype.isWalkable = function () {
  return this.isCloserThan(Distance.walkable);
};
</code></p>

<p>Then, when I decide I&rsquo;m too lazy to walk 5km, it only needs changing in one place.</p>
]]></content>
  </entry>
  
</feed>
